{
  "language": "Solidity",
  "sources": {
    "contracts/Crowdfund.sol": {
      "content": "// SPDX-License-Identifier:MIT\n\npragma solidity ^0.8.4;\n\nerror CrowdFund__TransferFailed();\nerror CrowdFund__NotCreator(string message);\nerror CrowdFund__MinimumContribution(\n    uint256 requiered,\n    uint256 actual,\n    string message\n);\nerror CrowdFund__HasClaimed(string message);\nerror CrowdFund__Goal(uint256 pledged, uint256 goal, string message);\nerror CrowdFund__TimeFailing(string message);\nerror CrowdFund__AmountFail();\n\ncontract Crowdfund {\n    event LaunchCampign(\n        uint256 id,\n        address indexed creator,\n        string description,\n        uint256 goal,\n        uint256 minimumContribution,\n        uint32 startAt,\n        uint32 endAt\n    );\n    event Pledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Claim(uint256 id);\n    event Cancel(uint256 id);\n    event Unpledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Refund(uint256 id, address indexed caller, uint256 amount);\n\n    struct Campaign {\n        address creator;\n        string description;\n        uint256 goal;\n        uint256 pledged;\n        uint32 startAt;\n        uint32 endAt;\n        bool claimed;\n        uint256 minimumContribution;\n    }\n\n    address private immutable i_owner;\n    uint256 private s_campaignCount;\n    mapping(uint256 => Campaign) private s_campaigns;\n    mapping(uint256 => mapping(address => uint256)) private s_pledgedAmount;\n\n    constructor(address _owner) {\n        i_owner = _owner;\n    }\n\n    function launchCampign(\n        string memory _description,\n        uint256 _goal,\n        uint256 _minimumContribution,\n        uint32 _startAt,\n        uint32 _endAt\n    ) external {\n        if (_startAt < block.timestamp)\n            revert CrowdFund__TimeFailing({message: \"start at < now\"});\n        if (_endAt < _startAt)\n            revert CrowdFund__TimeFailing({message: \"end at < start at\"});\n        if (_endAt > block.timestamp + 120 days)\n            revert CrowdFund__TimeFailing({message: \"end at > max duration\"});\n        s_campaignCount++;\n        s_campaigns[s_campaignCount] = Campaign({\n            creator: msg.sender,\n            description: _description,\n            pledged: 0,\n            goal: _goal,\n            minimumContribution: _minimumContribution,\n            startAt: _startAt,\n            endAt: _endAt,\n            claimed: false\n        });\n        emit LaunchCampign(\n            s_campaignCount,\n            msg.sender,\n            _description,\n            _goal,\n            _minimumContribution,\n            _startAt,\n            _endAt\n        );\n    }\n\n    function pledge(uint256 _id) public payable {\n        Campaign storage campaign = s_campaigns[_id];\n        if (block.timestamp < campaign.startAt)\n            revert CrowdFund__TimeFailing({message: \"not started\"});\n        if (block.timestamp > campaign.endAt)\n            revert CrowdFund__TimeFailing({message: \"ended\"});\n        if (msg.value < campaign.minimumContribution)\n            revert CrowdFund__MinimumContribution({\n                requiered: campaign.minimumContribution,\n                actual: msg.value,\n                message: \"send more contribution\"\n            });\n        campaign.pledged += msg.value;\n        s_pledgedAmount[_id][msg.sender] += msg.value;\n\n        emit Pledge(_id, msg.sender, msg.value);\n    }\n\n    function claim(uint256 _id) public {\n        Campaign storage campaign = s_campaigns[_id];\n        if (campaign.creator != msg.sender)\n            revert CrowdFund__NotCreator({message: \"Not creator\"});\n        if (block.timestamp < campaign.endAt)\n            revert CrowdFund__TimeFailing({message: \"not ended\"});\n        if (campaign.pledged < campaign.goal)\n            revert CrowdFund__Goal({\n                pledged: campaign.pledged,\n                goal: campaign.goal,\n                message: \"pledged < goal\"\n            });\n        if (campaign.claimed)\n            revert CrowdFund__HasClaimed({message: \"the campaing was claimed\"});\n\n        uint256 commission = campaign.goal / 100;\n\n        address payable creator = payable(campaign.creator);\n\n        (bool comissionSuccess, ) = payable(i_owner).call{value: commission}(\n            \"\"\n        );\n        (bool success, ) = creator.call{value: (campaign.pledged - commission)}(\n            \"\"\n        );\n        if (!success || !comissionSuccess) {\n            revert CrowdFund__TransferFailed();\n        }\n        campaign.claimed = true;\n        emit Claim(_id);\n    }\n\n    function cancel(uint256 _id) public {\n        Campaign memory campaign = s_campaigns[_id];\n        if (campaign.creator != msg.sender)\n            revert CrowdFund__NotCreator({message: \"Not creator\"});\n        if (block.timestamp > campaign.startAt)\n            revert CrowdFund__TimeFailing({message: \"started\"});\n        delete s_campaigns[_id];\n        emit Cancel(_id);\n    }\n\n    function unpledge(uint256 _id, uint256 _amount) public {\n        Campaign storage campaign = s_campaigns[_id];\n        if (block.timestamp > campaign.endAt)\n            revert CrowdFund__TimeFailing({message: \"ended\"});\n        if (s_pledgedAmount[_id][msg.sender] < _amount)\n            revert CrowdFund__AmountFail();\n        campaign.pledged -= _amount;\n        s_pledgedAmount[_id][msg.sender] -= _amount;\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        if (!success) {\n            revert CrowdFund__TransferFailed();\n        }\n\n        emit Unpledge(_id, msg.sender, _amount);\n    }\n\n    function refund(uint256 _id) public {\n        Campaign memory campaign = s_campaigns[_id];\n        if (block.timestamp < campaign.endAt)\n            revert CrowdFund__TimeFailing({message: \"not ended\"});\n        if (campaign.pledged > campaign.goal)\n            revert CrowdFund__Goal({\n                pledged: campaign.pledged,\n                goal: campaign.goal,\n                message: \"pledged >= goal\"\n            });\n        uint256 bal = s_pledgedAmount[_id][msg.sender];\n        s_pledgedAmount[_id][msg.sender] = 0;\n        (bool success, ) = payable(msg.sender).call{value: bal}(\"\");\n        if (!success) {\n            revert CrowdFund__TransferFailed();\n        }\n        emit Refund(_id, msg.sender, bal);\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getCampignsCount() public view returns (uint256) {\n        return s_campaignCount;\n    }\n\n    function getCampaignAtIndex(uint256 index)\n        public\n        view\n        returns (Campaign memory)\n    {\n        return s_campaigns[index];\n    }\n\n    function getMyPledgedAmount(uint256 index) public view returns (uint256) {\n        return s_pledgedAmount[index][msg.sender];\n    }\n}\n"
    },
    "contracts/CrowdfundFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"./Crowdfund.sol\";\n\ncontract CrowdfundFactory {\n    Crowdfund[] private s_crowdfundsDeployed;\n    address public immutable i_owner;\n    event crowdfundCreated(address crowdfundAddress);\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    function createCrowdfund() external {\n        Crowdfund crowdfund = new Crowdfund(i_owner);\n        s_crowdfundsDeployed.push(crowdfund);\n        emit crowdfundCreated(address(crowdfund));\n    }\n\n    function getCrowdfundDeployed() external view returns (Crowdfund[] memory) {\n        return s_crowdfundsDeployed;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}